import std/math
import std/sequtils
import std/sets
import std/setutils
import std/strscans
import std/sugar

type
    Resource = enum
        Ore = 0
        Clay = 1
        Obsidian = 2
        Geode = 3

    Robot = Resource

    ResourceCost = tuple
        cost: int
        resource: Resource

    Blueprint = object
        id: int
        roboCosts: array[Robot, seq[ResourceCost]]

const LINE_PATTERN =
    "Blueprint $i: " &
    "Each ore robot costs $i ore. " &
    "Each clay robot costs $i ore. " &
    "Each obsidian robot costs $i ore and $i clay. " &
    "Each geode robot costs $i ore and $i obsidian."

let blueprints: seq[Blueprint] = collect:
    for line in stdin.lines:
        let (
            success,
            blueprintId,
            oreRoboOreCost,
            clayRoboOreCost,
            obsidianRoboOreCost,
            obsidianRoboClayCost,
            geodeRoboOreCost,
            geodeRoboObsidianCost
        ) = line.scanTuple(LINE_PATTERN)
        assert success
        Blueprint(
            id: blueprintId,
            roboCosts: [
                @[(oreRoboOreCost, Ore)],
                @[(clayRoboOreCost, Ore)],
                @[(obsidianRoboOreCost, Ore), (obsidianRoboClayCost, Clay)],
                @[(geodeRoboOreCost, Ore), (geodeRoboObsidianCost, Obsidian)],
            ],
        )

const
    START_ORE_ROBOTS = 1

type
    State = object
        timeLeft: int
        # XXX: `Ore: START_ORE_ROBOTS` is needed to hint to the compiler that
        #       the default value is the declared type.
        #       See: https://github.com/nim-lang/Nim/issues/22926
        robots: array[Robot, int] = [Ore: START_ORE_ROBOTS, 0, 0, 0]
        resources: array[Resource, int]
        prevSkipped: set[Robot]

func next(s: State): State =
    result = s
    result.timeLeft -= 1
    for i in Resource:
        result.resources[i] += result.robots[i]
    result.prevSkipped = {}

func canBuildRobot(
    state: State,
    robotType: Robot,
    blueprint: Blueprint,
    resourceCaps: array[Resource, int],
): bool =
    # Don't build more robots if we have enough to build any other robot.
    if state.robots[robotType] >= resourceCaps[robotType]:
        return false

    # NOTE: Using sequtil.all() was costly because it was reaching out to
    #       `state` in the iteration. Thus, why this is a simple for-loop :).
    for (cost, resourceType) in blueprint.roboCosts[robotType]:
        if state.resources[resourceType] < cost:
            return false

    return true

func buildRobot(state: var State, robotType: Robot, blueprint: Blueprint) =
    let costs = blueprint.roboCosts[robotType]
    for x in costs:
        assert state.resources[x.resource] >= x.cost
        state.resources[x.resource] -= x.cost
    state.robots[robotType] += 1

func theoreticalBest(state: State, resourceType: Resource): int =
    let t = state.timeLeft

    # Resources we already have.
    let have = state.resources[resourceType]
    # Resources generated by existing robots.
    let harvestedExisting = state.robots[resourceType] * t
    # Resources generated as a new robot is built ever step.
    let harvestedByNew = t * (t - 1) div 2

    have + harvestedExisting + harvestedByNew

# NOTE: Use a closure iterator to allow terminating early with `return` statements.
iterator states(
    state: State,
    blueprint: Blueprint,
    resourceCaps: array[Resource, int],
    best: int,
): State {.closure.} =

    # Save branching because it doesn't make sense to build robots in the last minute.
    if state.timeLeft == 1:
        yield state.next()
        return

    # If the theoretical best case scenario for cracking geodes is less than
    # the best thus far, prune it.
    if theoreticalBest(state, Geode) < best:
        return

    # If there won't be a possibility of having enough obsidian to build more
    # geode robots, we know the answer.
    if theoreticalBest(state, Obsidian) < resourceCaps[Obsidian]:
        var nextState = state.next()
        nextState.resources[Geode] +=
            nextState.robots[Geode] * nextState.timeLeft
        nextState.timeLeft = 0
        yield nextState
        return

    # If a geode robot can be built, only consider this branch to get more
    # geodes and don't consider any other states.
    if state.canBuildRobot(Geode, blueprint, resourceCaps):
        var nextState = state.next()
        nextState.buildRobot(Geode, blueprint)
        yield nextState
        return

    # Otherwise, what other non-geode robots can be built?
    let buildableRobots = collect:
        for x in Ore..Obsidian:
            if state.canBuildRobot(x, blueprint, resourceCaps):
                x

    # Build those other robots.
    var nextState = state.next()
    for robotType in buildableRobots:
        # If could have built a robot in the previous state, it makes no sense
        # to wait to build it now; thus, prune this entire branch.
        # NOTE: This is the most significant optimization that brings
        # everything under a second.
        if state.prevSkipped.contains(robotType):
            continue

        var buildState = nextState
        buildState.buildRobot(robotType, blueprint)
        yield buildState

    nextState.prevSkipped = buildableRobots.toSet()
    yield nextState

func getMaxCosts(blueprint: Blueprint): array[Resource, int] =
    result = [0, 0, 0, int.high]
    for costs in blueprint.roboCosts:
        for (cost, resourceType) in costs:
            result[resourceType] = max(cost, result[resourceType])

func maxGeodesCracked(blueprint: Blueprint, timeRemaining: int): int =
    let resourceCaps = getMaxCosts(blueprint)

    var s = @[State(timeLeft: timeRemaining)]
    var seen: HashSet[State]
    while s.len != 0:
        let cur = s.pop()
        if cur.timeLeft == 0:
            result = max(cur.resources[Geode], result)
            continue
        if not seen.containsOrIncl(cur):
            for next in cur.states(blueprint, resourceCaps, result):
                s.add(next)

func qualityLevel(blueprint: Blueprint, geodes: int): int {.inline.} =
    blueprint.id * geodes

echo "Part 1: ", sum(blueprints.map((x) => qualityLevel(x, maxGeodesCracked(x, 24))))
echo "Part 2: ", prod(blueprints[0 ..< 3].map((x) => maxGeodesCracked(x, 32)))
